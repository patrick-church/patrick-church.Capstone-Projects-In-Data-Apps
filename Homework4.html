<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oversampling Methods on Porto Seguro Dataset</title>
    
    <!-- Include Highlight.js CSS and JavaScript for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <h1>Patrick Church</h1>
    <p>Date: November 11, 2024</p>

    <h2>Introduction</h2>
    <p>
        In this assignment, I will explore and compare different oversampling methods on the widely-used Porto Seguro Insurance dataset to address class imbalance. 
        I will demonstrate the use of several techniques, including SMOTE, ADASYN, FastKDE, and Normalizing Flows, to generate synthetic samples for the minority 
        class. Each method takes a unique approach to balancing the dataset, from interpolative sampling to density estimation and generative modeling. 
        By applying these methods, I aim to improve the model's ability to accurately identify minority class instances and provide a comparative analysis 
        of the effectiveness of each approach.
    </p>

    <h2>Class Distribution Visualization</h2>
    <h3>Code Snippet</h3>
    <pre><code class="language-python">
# Python code used to generate the bar plot
count = train['target'].value_counts()
count_zeros = count[0]
count_ones = count[1]
count.plot(kind='bar', title='Count of Target Variable')
    </code></pre>

    <h3>Description</h3>
    <p>
        The code snippet above counts the occurrences of each class in the target variable of the Porto Seguro dataset. 
        Using the <code>value_counts()</code> function, it calculates the number of samples for each class: class 0 (majority) 
        and class 1 (minority). This information is then plotted as a bar chart, showing the distribution of the two classes.
    </p>

    <h3>Interpretation of the Plot</h3>
    <p>
        The bar chart below visualizes the class imbalance in the dataset. The majority class (class 0) has a significantly higher count 
        than the minority class (class 1), which highlights the need for oversampling techniques. Oversampling generates synthetic 
        samples for the minority class, helping balance the dataset and allowing the model to better learn the characteristics of the minority class.
    </p>

    
    <img src="Images/count_of_target_variable (1).png" alt="Count of Target Variable" width="600">


    
    <h2>Sampling a 20% Subset of the Data</h2>

    <p>
        Due to the large size of the Porto Seguro dataset, processing the entire dataset can be computationally expensive and time-consuming. 
        To address this, I used a 20% stratified sampling approach, which helps reduce the dataset size while preserving the distribution of 
        the target variable. This ensures that the sample contains a representative proportion of each class.
    </p>

    <p>
        In the code, I first dropped the <code>target</code> and <code>id</code> columns from the original data and applied Min-Max scaling to normalize the features. 
        Then, I combined the scaled features and the target variable into a single DataFrame. Using the <code>groupby</code> function, I sampled 20% of the data 
        from each class. This stratified sampling helps maintain the original class balance in the subset, making it suitable for subsequent analysis and modeling.
    </p>

    
    <h3>Code Snippet</h3>
    <pre><code class="language-python">
# Python code to take a 20% sample from the dataset
X = train.drop(columns=['target', 'id'])
y = train['target']
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
sample_fraction = 0.2

data = pd.concat([pd.DataFrame(X_scaled), pd.Series(y, name="target")], axis=1)
data_sampled = data.groupby("target").sample(frac=sample_fraction, random_state=42)

X_sampled = data_sampled.drop(columns="target")
y_sampled = data_sampled["target"]
    </code></pre>

</body>
</html>
